<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>(Very) basic steps to weight a survey sample</title>
  <meta name="description" content="(Very) basic steps to weight a survey sample">
  <meta name="generator" content="bookdown 0.4 and GitBook 2.6.7">

  <meta property="og:title" content="(Very) basic steps to weight a survey sample" />
  <meta property="og:type" content="book" />
  
  
  
  <meta name="github-repo" content="JosepER/Book_How_to_weight_a_survey" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="(Very) basic steps to weight a survey sample" />
  
  
  

<meta name="author" content="Josep Espasa Reig">


<meta name="date" content="2017-06-29">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="import-data-management.html">
<link rel="next" href="nonresponse-weights.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Welcome to the introduction on how to weight a survey sample!</a></li>
<li class="chapter" data-level="1" data-path="introduction.html"><a href="introduction.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="introduction.html"><a href="introduction.html#aim-of-this-guide-and-further-readings"><i class="fa fa-check"></i><b>1.1</b> Aim of this guide and further readings</a></li>
<li class="chapter" data-level="1.2" data-path="introduction.html"><a href="introduction.html#basic_steps"><i class="fa fa-check"></i><b>1.2</b> Basic steps in weighting a survey</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="import-data-management.html"><a href="import-data-management.html"><i class="fa fa-check"></i><b>2</b> Import data and data management</a><ul>
<li class="chapter" data-level="2.0.1" data-path="import-data-management.html"><a href="import-data-management.html#import-data"><i class="fa fa-check"></i><b>2.0.1</b> Import data</a></li>
<li class="chapter" data-level="2.0.2" data-path="import-data-management.html"><a href="import-data-management.html#select-variables"><i class="fa fa-check"></i><b>2.0.2</b> Select variables</a></li>
<li class="chapter" data-level="2.0.3" data-path="import-data-management.html"><a href="import-data-management.html#merging-datafiles"><i class="fa fa-check"></i><b>2.0.3</b> Merging datafiles</a></li>
<li class="chapter" data-level="2.0.4" data-path="import-data-management.html"><a href="import-data-management.html#recoding"><i class="fa fa-check"></i><b>2.0.4</b> Recoding</a></li>
<li class="chapter" data-level="2.1" data-path="import-data-management.html"><a href="import-data-management.html#exploring-and-presenting-the-dataset"><i class="fa fa-check"></i><b>2.1</b> Exploring and presenting the dataset</a><ul>
<li class="chapter" data-level="2.1.1" data-path="import-data-management.html"><a href="import-data-management.html#paradata-variables"><i class="fa fa-check"></i><b>2.1.1</b> Paradata variables</a></li>
<li class="chapter" data-level="2.1.2" data-path="import-data-management.html"><a href="import-data-management.html#survey-responses"><i class="fa fa-check"></i><b>2.1.2</b> Survey responses</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="design-weights.html"><a href="design-weights.html"><i class="fa fa-check"></i><b>3</b> Step 1: Design weights</a></li>
<li class="chapter" data-level="4" data-path="nonresponse-weights.html"><a href="nonresponse-weights.html"><i class="fa fa-check"></i><b>4</b> Step 2: Non-response weights</a><ul>
<li class="chapter" data-level="4.1" data-path="nonresponse-weights.html"><a href="nonresponse-weights.html#what-are-of-non-response-weights"><i class="fa fa-check"></i><b>4.1</b> What are of non-response weights?</a></li>
<li class="chapter" data-level="4.2" data-path="nonresponse-weights.html"><a href="nonresponse-weights.html#estimating-response-propensities-using-logistic-regression"><i class="fa fa-check"></i><b>4.2</b> Estimating response propensities using logistic regression</a></li>
<li class="chapter" data-level="4.3" data-path="nonresponse-weights.html"><a href="nonresponse-weights.html#creating-non-response-adjustment-classes"><i class="fa fa-check"></i><b>4.3</b> Creating non-response adjustment classes</a></li>
<li class="chapter" data-level="4.4" data-path="nonresponse-weights.html"><a href="nonresponse-weights.html#testing-non-response-adjustment-classes"><i class="fa fa-check"></i><b>4.4</b> Testing non-response adjustment classes</a></li>
<li class="chapter" data-level="4.5" data-path="nonresponse-weights.html"><a href="nonresponse-weights.html#propensity_adjustment"><i class="fa fa-check"></i><b>4.5</b> Propensity adjustment (alternative to adjustment classes)</a><ul>
<li class="chapter" data-level="4.5.1" data-path="nonresponse-weights.html"><a href="nonresponse-weights.html#estimating-response-propensities-using-cross-validated-lasso-regression"><i class="fa fa-check"></i><b>4.5.1</b> Estimating response propensities using Cross-validated LASSO Regression</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="calibration.html"><a href="calibration.html"><i class="fa fa-check"></i><b>5</b> Step 3: Use of auxiliary data for weight calibration</a><ul>
<li class="chapter" data-level="5.1" data-path="calibration.html"><a href="calibration.html#preparing-data-for-calibration"><i class="fa fa-check"></i><b>5.1</b> Preparing data for calibration</a></li>
<li class="chapter" data-level="5.2" data-path="calibration.html"><a href="calibration.html#implementing-calibration"><i class="fa fa-check"></i><b>5.2</b> Implementing calibration</a></li>
<li class="chapter" data-level="5.3" data-path="calibration.html"><a href="calibration.html#testing-results-from-raked-weights"><i class="fa fa-check"></i><b>5.3</b> Testing results from raked weights</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="weight-variability.html"><a href="weight-variability.html"><i class="fa fa-check"></i><b>6</b> Step 4: Analysis of weight variability</a></li>
<li class="chapter" data-level="7" data-path="computing-estimates.html"><a href="computing-estimates.html"><i class="fa fa-check"></i><b>7</b> Computing weighted estimates</a></li>
<li class="chapter" data-level="8" data-path="note-for-non-probability-samples.html"><a href="note-for-non-probability-samples.html"><i class="fa fa-check"></i><b>8</b> Note for non-probability samples</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">(Very) basic steps to weight a survey sample</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="design_weights" class="section level1">
<h1><span class="header-section-number">3</span> Step 1: Design weights</h1>
<p>The first step in weighing is taking into account the different probabilities of being sampled that respondents may have. The 7th ESS did not use a register of people in the UK (in other countries they did). They first selected postcode sectors from the Post Office’s small user postcode address file (PAF) merging smaller sectors. The probability of each PAF of being selected was proportional to the number of addresses it contained. Then, they selected 20 addresses inside of each sampled PAF and a dwelling for each address. For each dewlling they selected a household and then a person in each household. The full explanation of the sampling procedure is given in page 163 of The data documentation report (<a href="http://www.europeansocialsurvey.org/docs/round7/survey/ESS7_data_documentation_report_e03_1.pdf">Edition 3.1</a>).</p>
<p>This sampling design is typical of survey frames where there is an available/public list of addresses but not a list of households or individuals. If we don’t weight this survey, we would probably over-represent people in addresses that have smaller number of dwellings, dwellings that include smaller number of households and households that comprise smaller number of people (we will actually see this below).</p>
<p>Fortunately for us, the probablity of each respondent of being sampled was computed by national experts and included in the 7th ESS dataset. In many projects, however, we would have to compute sampling probailities ourselves<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. A basic but important test that should be performed after computing the probabilities is <strong>making sure that all probabilities are between 0 and 1</strong>.</p>
<p>We will perform this test in the next chunk of code, which should give us an error if any of the probabilities is not in the interval <span class="math inline">\([0,1]\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">probabilities &lt;-<span class="st"> </span>data %&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">min.probability =</span> <span class="kw">min</span>(prob, <span class="dt">na.rm =</span> T),
            <span class="dt">max.probability =</span> <span class="kw">max</span>(prob, <span class="dt">na.rm =</span> T)) %&gt;%
<span class="st">  </span><span class="kw">as.vector</span>()

<span class="kw">print</span>(probabilities)</code></pre></div>
<pre><code>##   min.probability max.probability
## 1   0.00001269135    0.0002030616</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">if(probabilities$min.probability &lt;<span class="st"> </span><span class="dv">0</span>){<span class="kw">stop</span>(<span class="st">&quot;Minimum probability of being sampled is smaller than 0. Review sampling probabilities before computing base weights.&quot;</span>)}else if(probabilities$max.probability &gt;<span class="st"> </span><span class="dv">1</span>){<span class="kw">stop</span>(<span class="st">&quot;Maximum probability of being sampled is larger than 1. Review sampling probabilities before computing base weights.&quot;</span>)}

<span class="kw">rm</span>(probabilities)</code></pre></div>
<p>We see that there are actually 16 unique sampling probabilities computed in the dataset.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">unique</span>(<span class="kw">sort</span>(data$prob))</code></pre></div>
<pre><code>##  [1] 0.00001269135 0.00001682761 0.00001692180 0.00001846015 0.00002030616
##  [6] 0.00002256240 0.00002538271 0.00002900881 0.00003384361 0.00004061233
## [11] 0.00005076541 0.00006768721 0.00010153082 0.00013681033 0.00020306164</code></pre>
<p>The vast majority of respondents had probability of 0.0001015 or 0.00020306 (i.e. one in 9849 and one in 4925). We see a minority of around 15% of observations with smaller probabilities. These probabilities might seem very small. This is because the whole population is very large and the survey only sampled a small part of it.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(<span class="kw">round</span>(data$prob*<span class="dv">100</span>,<span class="dv">6</span>))</code></pre></div>
<pre><code>## 
## 0.001269 0.001683 0.001692 0.001846 0.002031 0.002256 0.002538 0.002901 
##        1        1        1        2        1        6        1        1 
## 0.003384 0.004061 0.005077 0.006769 0.010153 0.013681 0.020306 
##        6       22      101      188     1144        2      787</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(data, <span class="kw">aes</span>(<span class="dt">x =</span> prob)) +
<span class="st">  </span><span class="kw">geom_histogram</span>()</code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<p>The sampling probability of respondents seems to be related to the type of dwelling of respondents and the number of people in their household. We would have expected this as some types of dwellings might tend to be linked to a single address. For other (smaller) types there might usually be many dwellings sharing the same address<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>. Something similar would happen for size of household. Individuals in large households would have smaller probabilities of being sampled than individuals who are the only person in the household.</p>
<p>These differences in sampling probabilities across dweling type and household size show that, without any kind of adjustment, our sample would over-represent people living in certain types of dweling (e.g. ‘Multi-unit house, flat’) and people living in small households. If respondents from living in different types of dwellings and household sizes had differences in our <em>‘Y’</em> variables (e.g. smoked more or drank more alcohol) then our estimates from the survey sample would be biased.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">data %&gt;%
<span class="st">  </span><span class="kw">filter</span>(!<span class="kw">is.na</span>(prob)) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(type) %&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">n =</span> <span class="kw">n</span>(),
    <span class="dt">mean.prob.percentage =</span> <span class="kw">mean</span>(prob, <span class="dt">na.rm =</span> T)*<span class="dv">100</span>) %&gt;%
<span class="st">      </span><span class="kw">arrange</span>(<span class="kw">desc</span>(mean.prob.percentage))</code></pre></div>
<pre><code>## # A tibble: 11 x 3
##                                                type     n mean.prob.percentage
##                                              &lt;fctr&gt; &lt;int&gt;                &lt;dbl&gt;
##  1                                               NA     1           0.02030616
##  2         Multi-unit: Sheltered/retirement housing    21           0.01869456
##  3                           Multi-unit house, flat   346           0.01617988
##  4                                            Other    15           0.01601931
##  5                            House-trailer or boat     3           0.01353744
##  6                      Single unit: Terraced house   591           0.01338198
##  7 Only housing unit in building with other purpose     7           0.01305396
##  8                 Single unit: Semi-detached house   670           0.01213712
##  9                      Single unit: Detached house   582           0.01173768
## 10                                             Farm    24           0.01149272
## 11            Multi-unit: Student apartments, rooms     4           0.00412469</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">data %&lt;&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">hhmmb.factor =</span> <span class="kw">as.factor</span>(hhmmb) %&gt;%<span class="st"> </span><span class="kw">fct_recode</span>(<span class="st">`</span><span class="dt">+5</span><span class="st">`</span> =<span class="st"> &quot;6&quot;</span>,
                                                        <span class="st">`</span><span class="dt">+5</span><span class="st">`</span> =<span class="st"> &quot;7&quot;</span>,
                                                        <span class="st">`</span><span class="dt">+5</span><span class="st">`</span> =<span class="st"> &quot;8&quot;</span>))

data %&gt;%
<span class="st">  </span><span class="kw">filter</span>(!<span class="kw">is.na</span>(prob)) %&gt;%
<span class="st">  </span><span class="kw">filter</span>(!<span class="kw">is.na</span>(hhmmb.factor)) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(hhmmb.factor) %&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">n =</span> <span class="kw">n</span>(),
    <span class="dt">mean.prob.percentage =</span> <span class="kw">mean</span>(prob, <span class="dt">na.rm =</span> T)*<span class="dv">100</span>) %&gt;%
<span class="st">      </span><span class="kw">arrange</span>(<span class="kw">desc</span>(mean.prob.percentage))</code></pre></div>
<pre><code>## # A tibble: 6 x 3
##   hhmmb.factor     n mean.prob.percentage
##         &lt;fctr&gt; &lt;int&gt;                &lt;dbl&gt;
## 1            1   745          0.019260215
## 2            2   764          0.010841915
## 3            3   301          0.009803027
## 4            4   303          0.009026823
## 5            5   118          0.008328013
## 6           +5    33          0.007486616</code></pre>
<p>To solve these differences in sampling probabilities we have to compute <strong>design weights</strong> (sometimes also called <strong>base weights</strong>. The design weights are equal to the inverse of the probability of inclusion to the sample. Therefore, the design weight (<em>d<sub>0</sub></em>) of a respondent (<em>i</em>) will be equal to: <span class="math inline">\(d_{0i} = 1/\pi_{i}\)</span> where <span class="math inline">\(pi_{i}\)</span> is the probability of that unit of being included in the sampling.</p>
<p>Here we compute the design weight from the probability given in the ESS database.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">data %&lt;&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">base.weight =</span> <span class="dv">1</span>/prob)

data %&gt;%
<span class="st">  </span><span class="kw">select</span>(prob, base.weight) %&gt;%<span class="st"> </span><span class="kw">head</span>(<span class="dv">10</span>)</code></pre></div>
<pre><code>##             prob base.weight
## 1  0.00020306164    4924.613
## 2  0.00020306164    4924.613
## 3  0.00020306164    4924.613
## 4  0.00005076541   19698.452
## 5  0.00010153082    9849.226
## 6  0.00010153082    9849.226
## 7  0.00010153082    9849.226
## 8  0.00020306164    4924.613
## 9  0.00010153082    9849.226
## 10 0.00010153082    9849.226</code></pre>
<p>A simple interpretation of design weights it ‘the number of units in our population that each unit in our sample represents’. There is a simple but important test that we should perform after computing design weights. <strong>The sum of all design weights should be equal to the total number of units in our population</strong>. The ESS dataset for UK only included sampling probabilities for respondents (i.e. sampled units that responded to the survey!) but they did not include sampling probabilities of non-respondents. We can guess that this is because sampling probability depends on information that is obtained from the interview (i.e. number of people in household, number of households in dwelling, number of dwellings in adress, etc.). Not knowing the sampling probability for some sampled units is not an optimal situation.</p>
<p>The sum of our computed weights in the ESS dataset with 2,265 respondents equals 21,338,524. Doing a very simple Extrapolation to include the 3,335 non-respondents would give us a sum of weights equal to 52,757,499. This last figure would be much closer to the total UK population over 15.</p>
<p>It is a common practice for many researchers to scale the weights so that their sum equals the sample size (instead of the population size). Scaled weights would equally adjust for differences in sampling probabilities.</p>
<p>Here we compute our scaled design weights and we compare them with the ones given in the ESS dataset. We see that our weights scaled (<em>base.weigth.scaled</em>) are almost equal to those computed in the ESS dataset (<em>dweigth</em>). The small differences are probably due to rounding error.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">data %&gt;%
<span class="st">  </span><span class="kw">filter</span>(!<span class="kw">is.na</span>(base.weight)) %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(idno, base.weight) %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">base.weight.scaled =</span> base.weight/<span class="kw">sum</span>(base.weight, <span class="dt">na.rm =</span> T)*<span class="kw">nrow</span>(data[!<span class="kw">is.na</span>(data$prob),])) %&gt;%
<span class="st">  </span><span class="kw">left_join</span>(original.weights %&gt;%<span class="st"> </span><span class="kw">select</span>(idno, dweight),
            <span class="dt">by =</span> <span class="st">&quot;idno&quot;</span>) %&gt;%<span class="st"> </span><span class="kw">head</span>(<span class="dv">10</span>)</code></pre></div>
<pre><code>##         idno base.weight base.weight.scaled  dweight
## 1  100000003    4924.613          0.5224974 0.526796
## 2  100000005    4924.613          0.5224974 0.526796
## 3  100000008    4924.613          0.5224974 0.526796
## 4  100000009   19698.452          2.0899897 2.107184
## 5  100000010    9849.226          1.0449949 1.053592
## 6  100000012    9849.226          1.0449949 1.053592
## 7  100000015    9849.226          1.0449949 1.053592
## 8  100000016    4924.613          0.5224974 0.526796
## 9  100000017    9849.226          1.0449949 1.053592
## 10 100000020    9849.226          1.0449949 1.053592</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">data %&lt;&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">base.weight.scaled =</span> base.weight/<span class="kw">sum</span>(base.weight, <span class="dt">na.rm =</span> T)*<span class="kw">nrow</span>(data[!<span class="kw">is.na</span>(data$prob),]))</code></pre></div>
<p>As we mentioned before, design weights should sum up to the entire population from which the sample is drawn or to the total number of respondents if scaled as they did in the ESS. In this example both sums should equal 2,265.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">data %&gt;%
<span class="st">  </span><span class="kw">left_join</span>(original.weights %&gt;%<span class="st"> </span><span class="kw">select</span>(idno, dweight),
            <span class="dt">by =</span> <span class="st">&quot;idno&quot;</span>) %&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">sum.all.base.weights.scaled =</span> <span class="kw">sum</span>(base.weight.scaled, <span class="dt">na.rm =</span> T) %&gt;%<span class="st"> </span><span class="kw">round</span>(<span class="dv">0</span>),
            <span class="dt">sum.all.design.weights.ess =</span> <span class="kw">sum</span>(dweight, <span class="dt">na.rm =</span> T) %&gt;%<span class="st"> </span><span class="kw">round</span>(<span class="dv">0</span>))</code></pre></div>
<pre><code>##   sum.all.base.weights.scaled sum.all.design.weights.ess
## 1                        2264                       2264</code></pre>

</div>
<div class="footnotes">
<hr />
<ol start="1">
<li id="fn1"><p>In ‘real’ projects where we do the sampling ourselves we would have the sampling probability of both respondents and non-respondents. This example shows us that it is enough to know the probablity of inclsion of respondents.<a href="design-weights.html#fnref1">↩</a></p></li>
<li id="fn2"><p>As we explained before, this is relevant because sampling allocation inside Primary Sampling Units (postcode sectors) was proportional to the number of adresses in each of these. Therefore, if an address contains a large number of dwellings, each dwelling will have a smaller probability of being sampled than a dwelling that is the only one in an address.<a href="design-weights.html#fnref2">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="import-data-management.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="nonresponse-weights.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
